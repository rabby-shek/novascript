export enum TokenType {
  Number = "Number",
  String = "String",
  Boolean = "Boolean",
  Null = "Null",
  Undefined = "Undefined",
  Array = "Array",
  Object = "Object",
  Identifier = "Identifier",
  ArithmeticOperator = "ArithmeticOperator",
  AssignmentOperator = "AssignmentOperator",
  LogicalOperator = "LogicalOperator",
  ComparisonOperator = "ComparisonOperator",
  BitwiseOperator = "BitwiseOperator",
  Keyword = "Keyword",
  Punctuation = "Punctuation",
  Whitespace = "Whitespace",
  Comment = "Comment",
  Let = "Let",
  Const = "Const",
  Var = "Var",
  Function = "Function",
  Return = "Return",
  If = "If",
  Else = "Else",
  While = "While",
  For = "For",
  Do = "Do",
  Switch = "Switch",
  Case = "Case",
  Default = "Default",
  Break = "Break",
  Continue = "Continue",
  New = "New",
  Try = "Try",
  Catch = "Catch",
  Finally = "Finally",
  Throw = "Throw",
  Class = "Class",
  Extends = "Extends",
  Super = "Super",
  This = "This",
  Import = "Import",
  Export = "Export",
  From = "From",
  Async = "Async",
  Await = "Await",
  Type = "Type",
  Interface = "Interface",
  Enum = "Enum",
  Implements = "Implements",
  Private = "Private",
  Public = "Public",
  Protected = "Protected",
  Readonly = "Readonly",
  Static = "Static",
  Abstract = "Abstract",
  Declare = "Declare",
  Namespace = "Namespace",
  Module = "Module",
  Require = "Require",
  Infer = "Infer",
  Keyof = "Keyof",
  Is = "Is",
  As = "As",
  Satisfies = "Satisfies",
  Unique = "Unique",
  Unknown = "Unknown",
  Never = "Never",
  Any = "Any",
  Void = "Void",
  Symbol = "Symbol",
  TypeAlias = "TypeAlias",
  InterfaceDeclaration = "InterfaceDeclaration",
  Generic = "Generic",
  MappedType = "MappedType",
  ConditionalType = "ConditionalType",
  TemplateLiteralType = "TemplateLiteralType",
  IndexedAccessType = "IndexedAccessType",
  Tuple = "Tuple",
  Semicolon = "Semicolon",
  CurlyBracket = "CurlyBracket",
  SquareBracket = "SquareBracket",
  Parenthesis = "Parenthesis",
  Dot = "Dot",
  Colon = "Colon",
}

export const KEYWORDS: Record<string, TokenType> = {
  let: TokenType.Let,
  const: TokenType.Const,
  var: TokenType.Var,
  function: TokenType.Function,
  return: TokenType.Return,
  if: TokenType.If,
  else: TokenType.Else,
  while: TokenType.While,
  for: TokenType.For,
  do: TokenType.Do,
  switch: TokenType.Switch,
  case: TokenType.Case,
  default: TokenType.Default,
  break: TokenType.Break,
  continue: TokenType.Continue,
  new: TokenType.New,
  try: TokenType.Try,
  catch: TokenType.Catch,
  finally: TokenType.Finally,
  throw: TokenType.Throw,
  class: TokenType.Class,
  extends: TokenType.Extends,
  super: TokenType.Super,
  this: TokenType.This,
  import: TokenType.Import,
  export: TokenType.Export,
  from: TokenType.From,
  async: TokenType.Async,
  await: TokenType.Await,
  type: TokenType.Type,
  interface: TokenType.Interface,
  enum: TokenType.Enum,
  implements: TokenType.Implements,
  private: TokenType.Private,
  public: TokenType.Public,
  protected: TokenType.Protected,
  readonly: TokenType.Readonly,
  static: TokenType.Static,
  abstract: TokenType.Abstract,
  declare: TokenType.Declare,
  namespace: TokenType.Namespace,
  module: TokenType.Module,
  require: TokenType.Require,
  infer: TokenType.Infer,
  keyof: TokenType.Keyof,
  is: TokenType.Is,
  as: TokenType.As,
  satisfies: TokenType.Satisfies,
  unique: TokenType.Unique,
  unknown: TokenType.Unknown,
  never: TokenType.Never,
  any: TokenType.Any,
  void: TokenType.Void,
  symbol: TokenType.Symbol,
  typeAlias: TokenType.TypeAlias,
  interfaceDeclaration: TokenType.InterfaceDeclaration,
  generic: TokenType.Generic,
  mappedType: TokenType.MappedType,
  conditionalType: TokenType.ConditionalType,
  templateLiteralType: TokenType.TemplateLiteralType,
  indexedAccessType: TokenType.IndexedAccessType,
  tuple: TokenType.Tuple,
  colon: TokenType.Colon,
  number: TokenType.Number,
  string: TokenType.String,
  boolean: TokenType.Boolean,
  null: TokenType.Null,
  undefined: TokenType.Undefined,
};
